### 死锁的分析

| ID | Problem  
| --- | ---   |
| 001 |什么是死锁|
| 002 |发生死锁的例子|
| 002-1 |必定发生死锁|
| 003 |死锁的4个必要条件|
| 004 |死锁生产的实际情况|
| 005 |死锁的4个必要条件|
| 006 |如何定位死锁|
| 006-1 |修复死锁|


#### 什么是死锁 

1.发生在并发中

2.当两个线程持有对方所需要的资源又不主动释放 导致所有人都没有办法继续前进 这就是死锁 如果系统资源充足进程的资源请求都能满足死锁的可能性就会很低 否则就会因为争夺优先的资源而陷入死锁

#### 死锁的影响 

1.死锁在不同系统中的影响是不同的  取决于系统对于死锁的处理能力 

        ①比如数据库如果发生死锁会检测到死锁并放弃 
        ②jvm无法自动处理

#### 必定发生死锁 


#### 死锁的4个必要条件

1.互斥条件 一个资源每次只能被一个进程使用

2.请求和保持条件 一个进程因为请求而阻塞 对以获取的资源不释放

3.不剥夺条件 进程已获得资源 在未使用完之前不能强行剥夺

4.循环等待条件 若干线程形成首尾相接等待资源关系 

#### 转账操作

1.俩把锁

2.获取俩把锁成功 且余额大于0 则扣除转账人增加收款人的余额 是原子操作

3.顺序相反 则导致死锁

#### 定位死锁 

jstack 找到进程pid jps 定位 

threadMXbean 

#### 修复死锁策略

**保存案发线程然后立刻重启服务器然后进行排查 重新发布**

1.哲学家换手,转账换序策略

2.检测与恢复策略 ： 一段时间检测是否有死锁 如果有就剥夺某一个资源来打开死锁

3.鸵鸟策略： 鸵鸟这种动物 再运到危险的时候就会通常把头埋到地上 这样就不会看到危险 意思为 如果我们发生死锁的概率极低 那么就直接忽略他 这到死锁发生在人工恢复

#### 哲学家问题

概述：

     https://baike.baidu.com/item/%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98/10929794?fr=aladdin
     死锁： 每个人都饿了拿起左边的筷子永远都在等右边的筷子 